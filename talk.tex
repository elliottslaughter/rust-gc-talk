\documentclass[ignorenonframetext,12pt]{beamer}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifxetex
  \usepackage{fontspec,xltxtra,xunicode}
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
\else
  \ifluatex
    \usepackage{fontspec}
    \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \else
    \usepackage[utf8]{inputenc}
  \fi
\fi
\usepackage{listings}

\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

% Customize fonts
\setsansfont[Path = fonts/ubuntu/, UprightFont = *-Regular, BoldFont = *-Bold, ItalicFont = *-Italic, BoldItalicFont = *-BoldItalic]{Ubuntu}
\setmonofont[Path = fonts/ubuntumono/, UprightFont = *-Regular, BoldFont = *-Bold, ItalicFont = *-Italic, BoldItalicFont = *-BoldItalic]{UbuntuMono}

% Customize presentation defaults
\setbeamercolor{titlelike}{fg=black}
\setbeamercolor{itemize item}{fg=black}
\setbeamercolor{itemize subitem}{fg=black}
\setbeamercolor{itemize subsubitem}{fg=black}
\setbeamertemplate{navigation symbols}{}

% Custom language highlighting for Rust
\lstdefinelanguage{Rust}%
  {morekeywords={again,assert,break,const,do,drop,else,enum,%
      export,extern,fn,for,if,import,let,match,mod,new,%
      return,struct,trait,type,use,while},%
   sensitive,%
   morecomment=[s]{/*}{*/},%
   morecomment=[l]//,% nonstandard
   morestring=[b]",%
   morestring=[b]'%
  }[keywords,comments,strings,directives]%

\definecolor{darkblue}{rgb}{0,0,0.5}
\definecolor{darkgreen}{rgb}{0,0.5,0}

\lstset{%
keywordstyle=\color{darkblue},
commentstyle=\color{red},
stringstyle=\color{darkgreen},
showstringspaces=false%
}

\title{High-Performance Garbage Collection in Rust}
\author{Elliott Slaughter \textless{}slaughter@cs.stanford.edu\textgreater{}}
\date{August 30, 2012}

\begin{document}
\frame{\titlepage}

\begin{frame}
\Large\center{ Or, How to Hack LLVM's Support to Allow Us to Start
  Thinking About High-Performance Garbage Collection in Rust }
\end{frame}

\begin{frame}[fragile]\frametitle{Rust in 3 Contrived Examples}
\begin{itemize}
  \item<alert@2> Fast
  \item<alert@3> Safe
  \item<alert@4> Concurrent
\end{itemize}

\begin{overlayarea}{\textwidth}{\textheight}
\only<2>{\lstinputlisting[language=Rust]{example1.rs}}
\only<3>{\lstinputlisting[language=Rust]{example2.rs}}
\only<4>{\small\lstinputlisting[language=Rust]{example3.rs}}
\end{overlayarea}
\end{frame}

\begin{frame}\frametitle{Rust Memory Model}
\begin{itemize}
  \item Exchange heap
  \begin{itemize}
    \item Similar to C++11 \texttt{std::unique\_ptr}
    \item Exclusive ownership
    \item Move semantics
  \end{itemize}
  \item Task-local heap
  \begin{itemize}
    \item Similar to C++ \texttt{std::shared\_ptr}
    \item Reference counted
    \item Can't move between tasks
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Why Garbage Collection?}
\begin{itemize}
  \item Exchange heap
  \begin{itemize}
    \item Requires locking
    \item Sometimes awkward
  \end{itemize}
  \item Task-local heap
  \begin{itemize}
    \item Reference counting might not be as fast as you'd think
    \item Reference counting leaks cyclical references
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Secret Weapon(s)}
\begin{itemize}
  \item Only need to collect the task-local heap
  \begin{itemize}
    \item No locks
    \item Never stop the world
  \end{itemize}
  \item Optional, opt-in garbage collection
  \begin{itemize}
    \item Static guarrantee that tasks never GC unless opted-in
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Doesn't LLVM already support GC?}
\begin{itemize}
  \item Yes, but\ldots
\end{itemize}
\end{frame}

\end{document}
